<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>PwnSec2025-Opera</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false}
      ]
    });">
</script>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PwnSec2025-Opera | My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Challenge :
#!/usr/bin/env python3
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
from pwn import xor
import os, sys, random

FLAG = os.getenv(&#34;FLAG&#34;, &#34;flag{b3n34th_th3_m45k_pwnsecsocool}&#34;).encode()
    
class LCG:
    def __init__(self, m=1&lt;&lt;64):
        self.m = m
        self.a = random.getrandbits(64)|1
        self.c = random.getrandbits(64)|1
        self.x = random.getrandbits(64)
    def next(self): 
        self.x=(self.a*self.x&#43;self.c)%self.m
        return self.x
    def stream(self, n):
        out=b&#34;&#34;
        while len(out)&lt;n: out&#43;=self.next().to_bytes(8,&#34;big&#34;)
        return out[:n]

class RSA:
    def __init__(self, bits=512, e=65537):
        self.e=e
        self.p=getPrime(bits//2)
        self.q=getPrime(bits//2)
        self.n=self.p*self.q
    def enc(self, m_bytes, mod):
        k=(mod.bit_length()&#43;7)//8
        m=bytes_to_long(m_bytes)
        assert m&lt;mod
        return long_to_bytes(pow(m,self.e,mod),k)

def main():
    random.seed(os.urandom(16))
    rsa, lcg = RSA(bits=512), LCG()
    Cflag = rsa.enc(FLAG, rsa.n)
    enc_flag = xor(Cflag, lcg.stream(len(Cflag)))

    menu=&#34;1) get encrypted flag\n2) encrypt your input\n3) exit\n&gt; &#34;
    while True:
        try:
            c=input(menu).strip()
            if c==&#34;1&#34;:
                print(enc_flag.hex())
                print(rsa.n)  
            elif c==&#34;2&#34;:
                s=input(&#34;&gt; &#34;)
                m=s.encode()
                if bytes_to_long(m)&gt;=rsa.p: 
                    print(&#34;too long&#34;)
                    continue
                C=rsa.enc(m, rsa.p)
                print(xor(C, lcg.stream(len(C))).hex())  
            elif c==&#34;3&#34;:
                print(&#34;bye&#34;)
                return
            else: 
                print(&#34;don&#39;t waste our time&#34;)
                return
        except:
            print(&#34;error&#34;)
            sys.exit(0)

if __name__==&#34;__main__&#34;: main()% 
High level :
The challenge is consisted of two layers of &ldquo;pseudo-random generator LCG&rdquo; and an RSA scheme, and the two layers have very clear vulnerabilities.">
<meta name="author" content="">
<link rel="canonical" href="https://pi-1337.github.io/crypto-writeups/posts/pwnsec2025-opera/">
<link crossorigin="anonymous" href="/crypto-writeups/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pi-1337.github.io/crypto-writeups/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pi-1337.github.io/crypto-writeups/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pi-1337.github.io/crypto-writeups/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pi-1337.github.io/crypto-writeups/apple-touch-icon.png">
<link rel="mask-icon" href="https://pi-1337.github.io/crypto-writeups/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://pi-1337.github.io/crypto-writeups/posts/pwnsec2025-opera/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://pi-1337.github.io/crypto-writeups/posts/pwnsec2025-opera/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="PwnSec2025-Opera">
  <meta property="og:description" content="Challenge : #!/usr/bin/env python3 from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes from pwn import xor import os, sys, random FLAG = os.getenv(&#34;FLAG&#34;, &#34;flag{b3n34th_th3_m45k_pwnsecsocool}&#34;).encode() class LCG: def __init__(self, m=1&lt;&lt;64): self.m = m self.a = random.getrandbits(64)|1 self.c = random.getrandbits(64)|1 self.x = random.getrandbits(64) def next(self): self.x=(self.a*self.x&#43;self.c)%self.m return self.x def stream(self, n): out=b&#34;&#34; while len(out)&lt;n: out&#43;=self.next().to_bytes(8,&#34;big&#34;) return out[:n] class RSA: def __init__(self, bits=512, e=65537): self.e=e self.p=getPrime(bits//2) self.q=getPrime(bits//2) self.n=self.p*self.q def enc(self, m_bytes, mod): k=(mod.bit_length()&#43;7)//8 m=bytes_to_long(m_bytes) assert m&lt;mod return long_to_bytes(pow(m,self.e,mod),k) def main(): random.seed(os.urandom(16)) rsa, lcg = RSA(bits=512), LCG() Cflag = rsa.enc(FLAG, rsa.n) enc_flag = xor(Cflag, lcg.stream(len(Cflag))) menu=&#34;1) get encrypted flag\n2) encrypt your input\n3) exit\n&gt; &#34; while True: try: c=input(menu).strip() if c==&#34;1&#34;: print(enc_flag.hex()) print(rsa.n) elif c==&#34;2&#34;: s=input(&#34;&gt; &#34;) m=s.encode() if bytes_to_long(m)&gt;=rsa.p: print(&#34;too long&#34;) continue C=rsa.enc(m, rsa.p) print(xor(C, lcg.stream(len(C))).hex()) elif c==&#34;3&#34;: print(&#34;bye&#34;) return else: print(&#34;don&#39;t waste our time&#34;) return except: print(&#34;error&#34;) sys.exit(0) if __name__==&#34;__main__&#34;: main()% High level : The challenge is consisted of two layers of “pseudo-random generator LCG” and an RSA scheme, and the two layers have very clear vulnerabilities.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-03T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-03T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PwnSec2025-Opera">
<meta name="twitter:description" content="Challenge :
#!/usr/bin/env python3
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
from pwn import xor
import os, sys, random

FLAG = os.getenv(&#34;FLAG&#34;, &#34;flag{b3n34th_th3_m45k_pwnsecsocool}&#34;).encode()
    
class LCG:
    def __init__(self, m=1&lt;&lt;64):
        self.m = m
        self.a = random.getrandbits(64)|1
        self.c = random.getrandbits(64)|1
        self.x = random.getrandbits(64)
    def next(self): 
        self.x=(self.a*self.x&#43;self.c)%self.m
        return self.x
    def stream(self, n):
        out=b&#34;&#34;
        while len(out)&lt;n: out&#43;=self.next().to_bytes(8,&#34;big&#34;)
        return out[:n]

class RSA:
    def __init__(self, bits=512, e=65537):
        self.e=e
        self.p=getPrime(bits//2)
        self.q=getPrime(bits//2)
        self.n=self.p*self.q
    def enc(self, m_bytes, mod):
        k=(mod.bit_length()&#43;7)//8
        m=bytes_to_long(m_bytes)
        assert m&lt;mod
        return long_to_bytes(pow(m,self.e,mod),k)

def main():
    random.seed(os.urandom(16))
    rsa, lcg = RSA(bits=512), LCG()
    Cflag = rsa.enc(FLAG, rsa.n)
    enc_flag = xor(Cflag, lcg.stream(len(Cflag)))

    menu=&#34;1) get encrypted flag\n2) encrypt your input\n3) exit\n&gt; &#34;
    while True:
        try:
            c=input(menu).strip()
            if c==&#34;1&#34;:
                print(enc_flag.hex())
                print(rsa.n)  
            elif c==&#34;2&#34;:
                s=input(&#34;&gt; &#34;)
                m=s.encode()
                if bytes_to_long(m)&gt;=rsa.p: 
                    print(&#34;too long&#34;)
                    continue
                C=rsa.enc(m, rsa.p)
                print(xor(C, lcg.stream(len(C))).hex())  
            elif c==&#34;3&#34;:
                print(&#34;bye&#34;)
                return
            else: 
                print(&#34;don&#39;t waste our time&#34;)
                return
        except:
            print(&#34;error&#34;)
            sys.exit(0)

if __name__==&#34;__main__&#34;: main()% 
High level :
The challenge is consisted of two layers of &ldquo;pseudo-random generator LCG&rdquo; and an RSA scheme, and the two layers have very clear vulnerabilities.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pi-1337.github.io/crypto-writeups/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PwnSec2025-Opera",
      "item": "https://pi-1337.github.io/crypto-writeups/posts/pwnsec2025-opera/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PwnSec2025-Opera",
  "name": "PwnSec2025-Opera",
  "description": "Challenge : #!/usr/bin/env python3 from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes from pwn import xor import os, sys, random FLAG = os.getenv(\u0026#34;FLAG\u0026#34;, \u0026#34;flag{b3n34th_th3_m45k_pwnsecsocool}\u0026#34;).encode() class LCG: def __init__(self, m=1\u0026lt;\u0026lt;64): self.m = m self.a = random.getrandbits(64)|1 self.c = random.getrandbits(64)|1 self.x = random.getrandbits(64) def next(self): self.x=(self.a*self.x+self.c)%self.m return self.x def stream(self, n): out=b\u0026#34;\u0026#34; while len(out)\u0026lt;n: out+=self.next().to_bytes(8,\u0026#34;big\u0026#34;) return out[:n] class RSA: def __init__(self, bits=512, e=65537): self.e=e self.p=getPrime(bits//2) self.q=getPrime(bits//2) self.n=self.p*self.q def enc(self, m_bytes, mod): k=(mod.bit_length()+7)//8 m=bytes_to_long(m_bytes) assert m\u0026lt;mod return long_to_bytes(pow(m,self.e,mod),k) def main(): random.seed(os.urandom(16)) rsa, lcg = RSA(bits=512), LCG() Cflag = rsa.enc(FLAG, rsa.n) enc_flag = xor(Cflag, lcg.stream(len(Cflag))) menu=\u0026#34;1) get encrypted flag\\n2) encrypt your input\\n3) exit\\n\u0026gt; \u0026#34; while True: try: c=input(menu).strip() if c==\u0026#34;1\u0026#34;: print(enc_flag.hex()) print(rsa.n) elif c==\u0026#34;2\u0026#34;: s=input(\u0026#34;\u0026gt; \u0026#34;) m=s.encode() if bytes_to_long(m)\u0026gt;=rsa.p: print(\u0026#34;too long\u0026#34;) continue C=rsa.enc(m, rsa.p) print(xor(C, lcg.stream(len(C))).hex()) elif c==\u0026#34;3\u0026#34;: print(\u0026#34;bye\u0026#34;) return else: print(\u0026#34;don\u0026#39;t waste our time\u0026#34;) return except: print(\u0026#34;error\u0026#34;) sys.exit(0) if __name__==\u0026#34;__main__\u0026#34;: main()% High level : The challenge is consisted of two layers of \u0026ldquo;pseudo-random generator LCG\u0026rdquo; and an RSA scheme, and the two layers have very clear vulnerabilities.\n",
  "keywords": [
    
  ],
  "articleBody": "Challenge : #!/usr/bin/env python3 from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes from pwn import xor import os, sys, random FLAG = os.getenv(\"FLAG\", \"flag{b3n34th_th3_m45k_pwnsecsocool}\").encode() class LCG: def __init__(self, m=1\u003c\u003c64): self.m = m self.a = random.getrandbits(64)|1 self.c = random.getrandbits(64)|1 self.x = random.getrandbits(64) def next(self): self.x=(self.a*self.x+self.c)%self.m return self.x def stream(self, n): out=b\"\" while len(out)\u003cn: out+=self.next().to_bytes(8,\"big\") return out[:n] class RSA: def __init__(self, bits=512, e=65537): self.e=e self.p=getPrime(bits//2) self.q=getPrime(bits//2) self.n=self.p*self.q def enc(self, m_bytes, mod): k=(mod.bit_length()+7)//8 m=bytes_to_long(m_bytes) assert m\u003cmod return long_to_bytes(pow(m,self.e,mod),k) def main(): random.seed(os.urandom(16)) rsa, lcg = RSA(bits=512), LCG() Cflag = rsa.enc(FLAG, rsa.n) enc_flag = xor(Cflag, lcg.stream(len(Cflag))) menu=\"1) get encrypted flag\\n2) encrypt your input\\n3) exit\\n\u003e \" while True: try: c=input(menu).strip() if c==\"1\": print(enc_flag.hex()) print(rsa.n) elif c==\"2\": s=input(\"\u003e \") m=s.encode() if bytes_to_long(m)\u003e=rsa.p: print(\"too long\") continue C=rsa.enc(m, rsa.p) print(xor(C, lcg.stream(len(C))).hex()) elif c==\"3\": print(\"bye\") return else: print(\"don't waste our time\") return except: print(\"error\") sys.exit(0) if __name__==\"__main__\": main()% High level : The challenge is consisted of two layers of “pseudo-random generator LCG” and an RSA scheme, and the two layers have very clear vulnerabilities.\nVulnerabilities : The first is that the server doesn’t check for empty string, which we will take advantage of. And the second is that the server encrypt OUR message in RSA using the prime $p$, which is not secure at all, it is supposed to use $N$ as the modulus.\ns=input(\"\u003e \") # anything can go here (Vulnerability 1) m=s.encode() if bytes_to_long(m)\u003e=rsa.p: print(\"too long\") continue C=rsa.enc(m, rsa.p) # (Vulnerability 2) print(xor(C, lcg.stream(len(C))).hex()) The Attack : We first get the encrypted flag and also the modulus $N$. We encrypt the empty message \"\" (just once I did twice in order to confirm my way is correct). And then we encrypt any message, this step is involved in the RSA layer. The math : If s is an empty string then m = 0, thus we get the stream itself :\n$$ output = C \\oplus stream = Enc(m) \\oplus stream = 0 \\oplus stream = stream $$\nNow we just need to recover the LCG parameters $(a, c)$, and now recovering the Enc_flag is easy because we can reverse the LCG and go back to the previous states $x_i$, thus recovering $Enc(flag)$ which is :\n$$ EncFLAG = Enc(FLAG) = FLAG^e \\pmod{N} $$\nNow we need to break the RSA layer, and to do so, we need some math : We have the encrypted arbitrary text which I have chosen to be “A” so :\n$$ \\text{Let } A \\text{ be the integer representing “A”.} \\ A = \\mathrm{ord}(“A”) \\ $$\n$$ a \\equiv A^e \\pmod{p} \\ $$\n$$ b \\equiv A^e \\pmod{N} $$\nThis means:\n$$ a - b \\equiv 0 \\pmod{p} \\iff\\ p \\mid (a-b) $$\nSince $p$ is divisor of both $(a-b)$ and $N$, we can factor $N$ using GCD, so $p = gcd(N, a-b)$.\nThe Script : from chall import * # ================ first REQ (encrypt flag) =========================== N = 4916080727098179914441241519095552553856565700728450075108170059002990957939138896547105292967739166027945377243402934097595656728822101653101831279139531 enc_flag = bytes.fromhex(\"7522d4be9b90773ef12ac08c421cc5f530fca2fb770627b78b4bf6eb65cafd42160110520ec65a7f47710cf7656915e4ee1e13d2ed38d83d7207504acb66a968\") flaglen = len(enc_flag) # ================ second REQ (encrypt empty string) =========================== second_res = bytes.fromhex(\"d52700e2d5afba119e8b1ef7a43f3b80ce64e020c33c29add39fe92d6aa2edd4\") # ================ third REQ (encrypt empty string) =========================== third_res = bytes.fromhex(\"0b60eac0d73cdb29385180dd650321c8bdb94ae5bdf9c5855f993575d5929c5c\") # ================ forth REQ (encrypt \"A\") =========================== A_enc = bytes.fromhex(\"58f94332a306f99f84e95766814dd46f0931a2bcd3251f6bcf22ce3268fb3400\") # ================ SOLVE AJMI =========================== def recover_lcg_states(stream): m = 1 \u003c\u003c 64 xs = [int.from_bytes(stream[i:i+8], \"big\") for i in range(0, len(stream), 8)] x1, x2, x3 = xs[0], xs[1], xs[2] d1 = (x2 - x1) % m d2 = (x3 - x2) % m a = (d2 * pow(d1, -1, m)) % m c = (x2 - a*x1) % m return a, c, m a, c, m = recover_lcg_states(second_res) a, c, m = recover_lcg_states(third_res) # the first output is comfirmed to identical to the second ainv = pow(a, -1, m) def prev(x): return (ainv * (x - c)) % m def next(x): x=(a*x+c)%m return x xs3 = [int.from_bytes(third_res[i:i+8], \"big\") for i in range(0, len(third_res), 8)] xs2 = [int.from_bytes(second_res[i:i+8], \"big\") for i in range(0, len(second_res), 8)] print(\"doing good ? \", xs2[-1] == prev(xs3[0])) xs1 = [prev(x) for x in xs2] def complete_stream_prev(xs, l): need = (l - len(xs)) // len(xs[0].to_bytes(8,\"big\")) for _ in range(need): xs.insert(0, prev(xs[0])) def complete_stream_next(xs, l): need = (l - len(xs)) // len(xs[0].to_bytes(8,\"big\")) for _ in range(need): xs.append(next(xs[-1])) complete_stream_prev(xs1, len(enc_flag)) def xs_to_bytes(xs, n): out=b\"\" i=0 while len(out)\u003cn: out+=xs[i].to_bytes(8,\"big\") i = i+1 return out C0 = (xor(xs_to_bytes(xs1, flaglen), enc_flag)) print(C0.hex()) from Crypto.Util.number import * xs4 = [next(xs3[-1])] complete_stream_next(xs4, len(A_enc)) A = (xor(xs_to_bytes(xs4[-len(A_enc):], len(A_enc)), A_enc)) print(A) s=\"A\" m=s.encode() e = 0x10001 B = pow(bytes_to_long(m), e, N) import math p = (math.gcd(B-bytes_to_long(A), N)) print(p) print(\"are we good ? \", N%p==0 and p != 1) q=N//p # ========== Decrypt FLAG ============ print(long_to_bytes(pow(bytes_to_long(C0), pow(e, -1, (p-1)*(q-1)), N))) # ========== OUTPUT ============ # doing good ? True # 2c1a38c828a55d5f9e630a8f940a1385e15aec1252ac3fca89c1ad84a7372906e06ee4a7a3ca46062f6c7038d2df5a5c7d647aa2fe0015685c0eac70430144a4 # b'O{\\x04\\x9c?\\xf1.^\\xf4g\\xf6\\xde\\x08\\xf7\\xde\\xff\\x18\\xb4\\x0c^\\xd6\\x9f\\xa7\\xb6\\xaa\\xb8/\\x1aYnud' # 61737447455151085190911017044968419618689478567149066920180466069341485265367 # are we good ? True # b'flag{abc87ec0bc4741ab}'% ",
  "wordCount" : "780",
  "inLanguage": "en",
  "datePublished": "2025-05-03T00:00:00Z",
  "dateModified": "2025-05-03T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pi-1337.github.io/crypto-writeups/posts/pwnsec2025-opera/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pi-1337.github.io/crypto-writeups/favicon.ico"
    }
  }
}
</script></head>
<body><header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pi-1337.github.io/crypto-writeups/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">
    

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      PwnSec2025-Opera
    </h1>
    <div class="post-meta"><span title='2025-05-03 00:00:00 +0000 UTC'>May 3, 2025</span>

</div>
  </header> 
  <div class="post-content"><h1 id="challenge-">Challenge :<a hidden class="anchor" aria-hidden="true" href="#challenge-">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> getPrime, bytes_to_long, long_to_bytes
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> xor
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os<span style="color:#f92672">,</span> sys<span style="color:#f92672">,</span> random
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FLAG <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getenv(<span style="color:#e6db74">&#34;FLAG&#34;</span>, <span style="color:#e6db74">&#34;flag</span><span style="color:#e6db74">{b3n34th_th3_m45k_pwnsecsocool}</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>encode()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LCG</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, m<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">64</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>m <span style="color:#f92672">=</span> m
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>a <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>getrandbits(<span style="color:#ae81ff">64</span>)<span style="color:#f92672">|</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>c <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>getrandbits(<span style="color:#ae81ff">64</span>)<span style="color:#f92672">|</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>getrandbits(<span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next</span>(self): 
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>x<span style="color:#f92672">=</span>(self<span style="color:#f92672">.</span>a<span style="color:#f92672">*</span>self<span style="color:#f92672">.</span>x<span style="color:#f92672">+</span>self<span style="color:#f92672">.</span>c)<span style="color:#f92672">%</span>self<span style="color:#f92672">.</span>m
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stream</span>(self, n):
</span></span><span style="display:flex;"><span>        out<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> len(out)<span style="color:#f92672">&lt;</span>n: out<span style="color:#f92672">+=</span>self<span style="color:#f92672">.</span>next()<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">&#34;big&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> out[:n]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RSA</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, bits<span style="color:#f92672">=</span><span style="color:#ae81ff">512</span>, e<span style="color:#f92672">=</span><span style="color:#ae81ff">65537</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>e<span style="color:#f92672">=</span>e
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>p<span style="color:#f92672">=</span>getPrime(bits<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>q<span style="color:#f92672">=</span>getPrime(bits<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>n<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>p<span style="color:#f92672">*</span>self<span style="color:#f92672">.</span>q
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">enc</span>(self, m_bytes, mod):
</span></span><span style="display:flex;"><span>        k<span style="color:#f92672">=</span>(mod<span style="color:#f92672">.</span>bit_length()<span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>)<span style="color:#f92672">//</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>        m<span style="color:#f92672">=</span>bytes_to_long(m_bytes)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">assert</span> m<span style="color:#f92672">&lt;</span>mod
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> long_to_bytes(pow(m,self<span style="color:#f92672">.</span>e,mod),k)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
</span></span><span style="display:flex;"><span>    random<span style="color:#f92672">.</span>seed(os<span style="color:#f92672">.</span>urandom(<span style="color:#ae81ff">16</span>))
</span></span><span style="display:flex;"><span>    rsa, lcg <span style="color:#f92672">=</span> RSA(bits<span style="color:#f92672">=</span><span style="color:#ae81ff">512</span>), LCG()
</span></span><span style="display:flex;"><span>    Cflag <span style="color:#f92672">=</span> rsa<span style="color:#f92672">.</span>enc(FLAG, rsa<span style="color:#f92672">.</span>n)
</span></span><span style="display:flex;"><span>    enc_flag <span style="color:#f92672">=</span> xor(Cflag, lcg<span style="color:#f92672">.</span>stream(len(Cflag)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    menu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1) get encrypted flag</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">2) encrypt your input</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">3) exit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&gt; &#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>            c<span style="color:#f92672">=</span>input(menu)<span style="color:#f92672">.</span>strip()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> c<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;1&#34;</span>:
</span></span><span style="display:flex;"><span>                print(enc_flag<span style="color:#f92672">.</span>hex())
</span></span><span style="display:flex;"><span>                print(rsa<span style="color:#f92672">.</span>n)  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> c<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;2&#34;</span>:
</span></span><span style="display:flex;"><span>                s<span style="color:#f92672">=</span>input(<span style="color:#e6db74">&#34;&gt; &#34;</span>)
</span></span><span style="display:flex;"><span>                m<span style="color:#f92672">=</span>s<span style="color:#f92672">.</span>encode()
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> bytes_to_long(m)<span style="color:#f92672">&gt;=</span>rsa<span style="color:#f92672">.</span>p: 
</span></span><span style="display:flex;"><span>                    print(<span style="color:#e6db74">&#34;too long&#34;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                C<span style="color:#f92672">=</span>rsa<span style="color:#f92672">.</span>enc(m, rsa<span style="color:#f92672">.</span>p)
</span></span><span style="display:flex;"><span>                print(xor(C, lcg<span style="color:#f92672">.</span>stream(len(C)))<span style="color:#f92672">.</span>hex())  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> c<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;3&#34;</span>:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">&#34;bye&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>: 
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">&#34;don&#39;t waste our time&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;error&#34;</span>)
</span></span><span style="display:flex;"><span>            sys<span style="color:#f92672">.</span>exit(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__<span style="color:#f92672">==</span><span style="color:#e6db74">&#34;__main__&#34;</span>: main()<span style="color:#f92672">%</span> 
</span></span></code></pre></div><h1 id="high-level-">High level :<a hidden class="anchor" aria-hidden="true" href="#high-level-">#</a></h1>
<p>The challenge is consisted of two layers of &ldquo;pseudo-random generator LCG&rdquo; and an RSA scheme, and the two layers have very clear vulnerabilities.</p>
<h1 id="vulnerabilities-">Vulnerabilities :<a hidden class="anchor" aria-hidden="true" href="#vulnerabilities-">#</a></h1>
<p>The first is that the server doesn&rsquo;t check for empty string, which we will take advantage of.
And the second is that the server encrypt OUR message in RSA using the prime $p$, which is not secure at all, it is supposed to use $N$ as the modulus.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>s<span style="color:#f92672">=</span>input(<span style="color:#e6db74">&#34;&gt; &#34;</span>) <span style="color:#75715e"># anything can go here (Vulnerability 1)</span>
</span></span><span style="display:flex;"><span>m<span style="color:#f92672">=</span>s<span style="color:#f92672">.</span>encode()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> bytes_to_long(m)<span style="color:#f92672">&gt;=</span>rsa<span style="color:#f92672">.</span>p: 
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;too long&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>C<span style="color:#f92672">=</span>rsa<span style="color:#f92672">.</span>enc(m, rsa<span style="color:#f92672">.</span>p) <span style="color:#75715e"># (Vulnerability 2)</span>
</span></span><span style="display:flex;"><span>print(xor(C, lcg<span style="color:#f92672">.</span>stream(len(C)))<span style="color:#f92672">.</span>hex())  
</span></span></code></pre></div><h1 id="the-attack-">The Attack :<a hidden class="anchor" aria-hidden="true" href="#the-attack-">#</a></h1>
<ol>
<li>We first get the encrypted flag and also the modulus $N$.</li>
<li>We encrypt the empty message &quot;&quot; (just once I did twice in order to confirm my way is correct).</li>
<li>And then we encrypt any message, this step is involved in the RSA layer.</li>
</ol>
<h3 id="the-math-">The math :<a hidden class="anchor" aria-hidden="true" href="#the-math-">#</a></h3>
<p>If s is an empty string then m = 0, thus we get the stream itself :</p>
<p>$$
output = C \oplus stream = Enc(m) \oplus stream = 0 \oplus stream = stream
$$</p>
<p>Now we just need to recover the LCG parameters $(a, c)$, and now recovering the Enc_flag is easy because we can reverse the LCG and go back to the previous states $x_i$, thus recovering $Enc(flag)$
which is :</p>
<p>$$
EncFLAG
= Enc(FLAG) = FLAG^e \pmod{N}
$$</p>
<p>Now we need to break the RSA layer, and to do so, we need some math :
We have the encrypted arbitrary text which I have chosen to be &ldquo;A&rdquo; so :</p>
<p>$$
\text{Let } A \text{ be the integer representing &ldquo;A&rdquo;.} \
A = \mathrm{ord}(&ldquo;A&rdquo;) \
$$</p>
<p>$$
a \equiv A^e \pmod{p} \
$$</p>
<p>$$
b \equiv A^e \pmod{N}
$$</p>
<p>This means:</p>
<p>$$
a - b \equiv 0 \pmod{p} \iff\ p \mid (a-b)
$$</p>
<p>Since $p$ is divisor of both $(a-b)$ and $N$, we can factor $N$ using GCD, so $p = gcd(N, a-b)$.</p>
<h1 id="the-script-">The Script :<a hidden class="anchor" aria-hidden="true" href="#the-script-">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> chall <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ================ first REQ (encrypt flag) ===========================</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">4916080727098179914441241519095552553856565700728450075108170059002990957939138896547105292967739166027945377243402934097595656728822101653101831279139531</span>
</span></span><span style="display:flex;"><span>enc_flag <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;7522d4be9b90773ef12ac08c421cc5f530fca2fb770627b78b4bf6eb65cafd42160110520ec65a7f47710cf7656915e4ee1e13d2ed38d83d7207504acb66a968&#34;</span>)
</span></span><span style="display:flex;"><span>flaglen <span style="color:#f92672">=</span> len(enc_flag)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ================ second REQ (encrypt empty string) ===========================</span>
</span></span><span style="display:flex;"><span>second_res <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;d52700e2d5afba119e8b1ef7a43f3b80ce64e020c33c29add39fe92d6aa2edd4&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ================ third REQ (encrypt empty string) ===========================</span>
</span></span><span style="display:flex;"><span>third_res <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;0b60eac0d73cdb29385180dd650321c8bdb94ae5bdf9c5855f993575d5929c5c&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ================ forth REQ (encrypt &#34;A&#34;) ===========================</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A_enc <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#34;58f94332a306f99f84e95766814dd46f0931a2bcd3251f6bcf22ce3268fb3400&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ================ SOLVE AJMI ===========================</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recover_lcg_states</span>(stream):
</span></span><span style="display:flex;"><span>    m <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>    xs <span style="color:#f92672">=</span> [int<span style="color:#f92672">.</span>from_bytes(stream[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>], <span style="color:#e6db74">&#34;big&#34;</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(stream), <span style="color:#ae81ff">8</span>)]
</span></span><span style="display:flex;"><span>    x1, x2, x3 <span style="color:#f92672">=</span> xs[<span style="color:#ae81ff">0</span>], xs[<span style="color:#ae81ff">1</span>], xs[<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>    d1 <span style="color:#f92672">=</span> (x2 <span style="color:#f92672">-</span> x1) <span style="color:#f92672">%</span> m
</span></span><span style="display:flex;"><span>    d2 <span style="color:#f92672">=</span> (x3 <span style="color:#f92672">-</span> x2) <span style="color:#f92672">%</span> m
</span></span><span style="display:flex;"><span>    a <span style="color:#f92672">=</span> (d2 <span style="color:#f92672">*</span> pow(d1, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, m)) <span style="color:#f92672">%</span> m
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> (x2 <span style="color:#f92672">-</span> a<span style="color:#f92672">*</span>x1) <span style="color:#f92672">%</span> m
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a, c, m
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>a, c, m <span style="color:#f92672">=</span> recover_lcg_states(second_res)
</span></span><span style="display:flex;"><span>a, c, m <span style="color:#f92672">=</span> recover_lcg_states(third_res)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the first output is comfirmed to identical to the second</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ainv <span style="color:#f92672">=</span> pow(a, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, m)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prev</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (ainv <span style="color:#f92672">*</span> (x <span style="color:#f92672">-</span> c)) <span style="color:#f92672">%</span> m
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next</span>(x): 
</span></span><span style="display:flex;"><span>    x<span style="color:#f92672">=</span>(a<span style="color:#f92672">*</span>x<span style="color:#f92672">+</span>c)<span style="color:#f92672">%</span>m
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xs3 <span style="color:#f92672">=</span> [int<span style="color:#f92672">.</span>from_bytes(third_res[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>], <span style="color:#e6db74">&#34;big&#34;</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(third_res), <span style="color:#ae81ff">8</span>)]
</span></span><span style="display:flex;"><span>xs2 <span style="color:#f92672">=</span> [int<span style="color:#f92672">.</span>from_bytes(second_res[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>], <span style="color:#e6db74">&#34;big&#34;</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(second_res), <span style="color:#ae81ff">8</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;doing good ? &#34;</span>, xs2[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> prev(xs3[<span style="color:#ae81ff">0</span>]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xs1 <span style="color:#f92672">=</span> [prev(x) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> xs2]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">complete_stream_prev</span>(xs, l):
</span></span><span style="display:flex;"><span>    need <span style="color:#f92672">=</span> (l <span style="color:#f92672">-</span> len(xs)) <span style="color:#f92672">//</span> len(xs[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(need):
</span></span><span style="display:flex;"><span>        xs<span style="color:#f92672">.</span>insert(<span style="color:#ae81ff">0</span>, prev(xs[<span style="color:#ae81ff">0</span>]))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">complete_stream_next</span>(xs, l):
</span></span><span style="display:flex;"><span>    need <span style="color:#f92672">=</span> (l <span style="color:#f92672">-</span> len(xs)) <span style="color:#f92672">//</span> len(xs[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">&#34;big&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(need):
</span></span><span style="display:flex;"><span>        xs<span style="color:#f92672">.</span>append(next(xs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>complete_stream_prev(xs1, len(enc_flag))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">xs_to_bytes</span>(xs, n):
</span></span><span style="display:flex;"><span>    out<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> len(out)<span style="color:#f92672">&lt;</span>n:
</span></span><span style="display:flex;"><span>        out<span style="color:#f92672">+=</span>xs[i]<span style="color:#f92672">.</span>to_bytes(<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">&#34;big&#34;</span>)
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>C0 <span style="color:#f92672">=</span> (xor(xs_to_bytes(xs1, flaglen), enc_flag))
</span></span><span style="display:flex;"><span>print(C0<span style="color:#f92672">.</span>hex())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Util.number <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xs4 <span style="color:#f92672">=</span> [next(xs3[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])]
</span></span><span style="display:flex;"><span>complete_stream_next(xs4, len(A_enc))
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">=</span> (xor(xs_to_bytes(xs4[<span style="color:#f92672">-</span>len(A_enc):], len(A_enc)), A_enc))
</span></span><span style="display:flex;"><span>print(A)
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;A&#34;</span>
</span></span><span style="display:flex;"><span>m<span style="color:#f92672">=</span>s<span style="color:#f92672">.</span>encode()
</span></span><span style="display:flex;"><span>e <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10001</span>
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">=</span> pow(bytes_to_long(m), e, N)
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> math
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> (math<span style="color:#f92672">.</span>gcd(B<span style="color:#f92672">-</span>bytes_to_long(A), N))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(p)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;are we good ? &#34;</span>, N<span style="color:#f92672">%</span>p<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> p <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">=</span>N<span style="color:#f92672">//</span>p
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ========== Decrypt FLAG ============</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(long_to_bytes(pow(bytes_to_long(C0), pow(e, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, (p<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>(q<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)), N)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ========== OUTPUT ============</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># doing good ?  True</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2c1a38c828a55d5f9e630a8f940a1385e15aec1252ac3fca89c1ad84a7372906e06ee4a7a3ca46062f6c7038d2df5a5c7d647aa2fe0015685c0eac70430144a4</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># b&#39;O{\x04\x9c?\xf1.^\xf4g\xf6\xde\x08\xf7\xde\xff\x18\xb4\x0c^\xd6\x9f\xa7\xb6\xaa\xb8/\x1aYnud&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 61737447455151085190911017044968419618689478567149066920180466069341485265367</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># are we good ?  True</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># b&#39;flag{abc87ec0bc4741ab}&#39;%  </span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
  </main>
<footer class="footer">
        <span>&copy; 2026 <a href="https://pi-1337.github.io/crypto-writeups/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>
</html>

